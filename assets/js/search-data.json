{
  
    
        "post0": {
            "title": "",
            "content": "DataFrame . You can think of DataFrame like a spreadsheet or SQL table. It is the most commonly used pandas object. Rows are referred to as axis 0 and columns as axis 1 and each axis can have multiple levels (which is not common). . Creating a DataFrame . Below example is to create sample DataFrame for examples on this page . import pandas as pd df=pd.DataFrame(data=[[&#39;apple&#39;,&#39;fruit&#39;,85,3], # Natural line breaking allowed for code within parentheses() [&#39;orange&#39;,&#39;fruit&#39;,68,1], [&#39;banana&#39;,&#39;fruit&#39;,69,2], [&#39;beetroot&#39;,&#39;vegetable&#39;,68,1], [&#39;carrot&#39;,&#39;vegetable&#39;,45,2]], columns=[&#39;name&#39;,&#39;type&#39;,&#39;health_index&#39;,&#39;cost_index&#39;]) df # prints the dataframe . Result: {F34356671} . Datatypes &amp; conversions . Available datatypes: object (string, lists, dict, tuple and other complex objects), int64, float64, datetime64 . #string s=&#39;hello world!&#39; #s[0:2] returns &#39;he&#39;, s[:-1] returns &#39;hello world&#39; #list a=[1,4,5,1,3,6] # a[0] gets first element; a[-1] gets last element. Lists elements can be added or removed with a.append(elem) or a.pop(elem) #dict d={&#39;movie_name&#39;:&#39;star wars&#39;, &#39;rating&#39;:5} # d[&#39;movie_name&#39;] gets &#39;star wars&#39;. Dict elements can be added or removed using d[&#39;release_year&#39;]=1977 or del d[&#39;rating&#39;] #tuple t=(&#39;apple&#39;,&#39;iphone&#39;,&#39;7 plus&#39;) # similar to list, t[0] gets first element. Tuples are immutable. cannot add/change values #complex objects (combination of two or more of above) c={&#39;product&#39;:(&#39;apple&#39;,&#39;iphone&#39;,&#39;7 plus&#39;),&#39;features&#39;:[&#39;bluetooth&#39;,&#39;wifi&#39;]} . Get data types for each column in a data frame . df.dtypes # gives the number of columns by various data types in the dataframe df . Convert string/object to numeric . Pandas auto-detects data type. Usually numeric column with nulls or few string values are treated as object. This piece of code will replace them to 0 and convert to int . df.ID = pd.to_numeric(df.ID, errors=&#39;coerce&#39;) # coerce converts non numeric value columns to NaN .fillna(0) # replaces NaN to 0 .astype(np.int64) # type conversion . Other conversions . dict(obj) # converts object to dict list(tup) # converts tuple to list tuple(list) # converts list to tuple . Select columns . Simple select . df[col1] # Returns series df[[col1]] # Returns dataframe with 1 col df.loc[:,[col1]] #Same as above, : refers to all rows df.iloc[:,[0]] # Returns dataframe with 1st col df[[col1,col2]] # Returns dataframe with 2 cols df.loc[:,[col1,col2]] # Same as above df.iloc[:,[0:3]] #Retuns dataframe with first 3 columns (0,1,2) . more creative selects from a list here . Select from multi-level index using tuples . The tuples () can have 2 or more levels . df[(&#39;label&#39;,&#39;count&#39;),(&#39;label&#39;,&#39;mean&#39;)] # selects 2 columns (first under tree label-&gt;count and second label-&gt;mean) . Creating multi-level index using tuples . The tuples () can have 2 or more levels . pd.MultiIndex.from_tuples([(&#39;Parent1&#39;, &#39;Child1&#39;), (&#39;Parent1&#39;, &#39;Child2&#39;)], names=[&#39;Parent&#39;, &#39;Child&#39;]) . Alternatively, you can construct a list and convert to tuple using zip: . arrays = [[&#39;Parent1&#39;,&#39;Parent1&#39;], [&#39;Child1&#39;, &#39;Child2&#39;]] tuples = list(zip(*arrays)) pd.MultiIndex.from_tuples(tuples, names=[&#39;Parent&#39;, &#39;Child&#39;]) . Programmatically select columns . df[[col for col in df if &#39;prob&#39; in col]] # selects all columns containing &#39;prob&#39; in column name . Get distribution of values in a column . df.health_index.value_counts() # record count for each val df.health_index.value_counts(normalize=True) # % distribution . Filter rows . Filters internally use masking. You can just run the filter inside to see the mask data frame. . df.loc[df.col1.isin([&#39;apple&#39;,&#39;orange&#39;]),:] # Returns all records where col1 is &#39;apple&#39; or &#39;orange&#39; df.loc[~df.col1.isin([&#39;apple&#39;,&#39;orange&#39;]),:] # Returns all records where col1 is not &#39;apple&#39; or &#39;orange&#39; . Sort . Sort rows . df.sort_values(&#39;trips_per_user&#39;) #Sorts rows based on values in trips_per_user . Sort columns . df.sort_index(axis=1,level=0) # Sorts columns by their names. axis 1 refers to columns. level 0 is the highest/default level . Group by . Group by example . groupby returns a dict object with group name and group data frame. This can be iterated thru manually or summarized using the functions below. NULL value (NA, NaT) will be ignored and will not form a group. . df.groupby(&#39;email_domain&#39;) df.groupby(column_list) . Tip: You could also group by on a field which is not in the selector (even from another dataframe as long as indexes match up) . df[&#39;cost_index&#39;].groupby(df.type).sum() . Tip: Group by fields are added to index in the resulting dataframe. Use reset_index() to move the index to columns . df.groupby(column_list).sum().reset_index() . Aggregate functions . apply a common operation on all non grouped columns If an aggregate function cannot be applied on a column eg.string, these nuisance columns will be silently ignored . .size() # count .sum() # supports prod, min, max, mean, median, first, last, std, var .head(5) # returns first 5 rows in each group by order as in dataframe. also supports tail(n), nlargest(n), nsmallest(n) .nth([4,-1]) # returns 4th element from the top and 1st element from the bottom . apply various operations on each of the columns . .agg({&#39;col1&#39;:[&#39;mean&#39;,&#39;count&#39;],&#39;col2&#39;:[&#39;var&#39;]}) . % of total within groups . df[&#39;health_index_%oftotal&#39;]=df.health_index/df.health_index.sum() . Transform functions . Transform function is similar to window aggregate functions on the entire window. It aggregates the data and assigns back to dataset similar to original and preserves index . df.groupby(&#39;type&#39;)[&#39;health_index&#39;].transform(&#39;sum&#39;) # supports all aggregate functions like min, max, mean, std, var . Group Filters (SQL:having) . dff.groupby(&#39;B&#39;).filter(lambda x: len(x[&#39;C&#39;]) &gt; 2) #Refer Lambda functions . Window aggregate functions . Overall . Applying math function on a series aggregates to the entire group. When applied on group by, returns aggregate value for each group . df.health_index.sum() . We could use this to divide on individual values to create % of total columns . df[&#39;health_index_%oftotal&#39;]=df.health_index/df.health_index.sum() . Simple Cumulative . df.cost_index.cumsum(asending=False) # similar functions: cummin, cummax, cumprod . Expanding Window . Another way of achieving cumulative sum: . df.cost_index.expanding().sum() . Rolling Window . Similar to expanding, rolling window is also supported. Here is how to do a rolling sum of current record and previous (n-1) records . df.cost_index.rolling(2).sum() . Lead/Lag . df.cost_index.shift(-2) # Get value from 2 records before df.cost_index.shift(1) # Get value from next record . Resample . Used for time series grouping to create bins of equi-split time intervals . # Get another example! df_re.groupby(&#39;group&#39;).resample(&#39;1D&#39;).sum() . To check if window aggregate functions are working fine, validate alongside your original dataset like below: . pd.concat([df,df.cost_index.rolling(2,min_periods=1).mean()], axis=1) . Note: No exact equivalent of rows between n preceding and n following found in pandas. Please update when you find it . Joins . Simple join . train_X.join(train[y_col]) # joins on index. Returns dataframe with all columns from train_X &amp; y_col from train . Concat columns . concat on axis 1 is like join based on index . pd.concat([df1, df4], axis=1) . SQL like join . SQL like join can be achieved with merge: . pd.merge(left, right, how=&#39;inner&#39;, on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=True, suffixes=(&#39;_x&#39;, &#39;_y&#39;), copy=True, indicator=False, validate=None) . Aggregate and join back to original dataset . df.join(df.groupby(&#39;month&#39;)[&#39;A&#39;].sum(), on=&#39;month&#39;, rsuffix=&#39;_r&#39;) # aggregates column A to month level and adds that to each of the records in df and is returned . Formatting . Numeric formating . df.style.format({&#39;B&#39;: &#39;{:0&lt;4.0f}&#39;, &#39;D&#39;: &#39;{:+.2%}&#39;},&#39;C&#39;:&#39;±{:.2f}&#39;) # {:+.2%} is for % with 2 decimals # ±{:.2f} is for 2 decimals with a +- sign in the front, # {:0&lt;4.0f} 0 in front fills zero, &lt; for is left aligned, 4 digits (including - sign) before decimal and no value after decimal . Numeric format guides: here . Gradient Background . cm = sns.light_palette(&#39;green&#39;, as_cmap=True) df.style.background_gradient(cmap=cm, subset=[&#39;B&#39;, &#39;C&#39;, &#39;D’]) # applies heatmap for columns B, C, D . Bars . df.style.bar(subset=[&#39;B&#39;]) # applies bars to column B . Nesting multiple styles . df.style.format({&#39;B&#39;: &#39;{:0&lt;4.0f}&#39;, &#39;D&#39;: &#39;{:+.2f}&#39;}).bar(subset=[&#39;B&#39;]) . More styles: here . Transform . Swap level &amp; Axis . df.swaplevel(i=0,j=1,axis=1) # swaps first 2 levels (0 &amp; 1) on columns (axis 1) df.swapindex(0,1) # swaps first 2 index columns . Map . df[&#39;housing&#39;].map({&#39;yes&#39;: 1, &#39;no&#39;: 0}) # changes values &#39;yes&#39; to 1 and &#39;no&#39; to 0 . Apply . using lambda functions for column transformations (entire column is passed as series to lambda function) . df[&#39;delayed&#39;] = df[&#39;arr_delay&#39;].apply(lambda col: col &gt; 0) . using lambda function across columns using axis=1 . df[&#39;Value&#39;] = df.apply(lambda row: my_test(row[&#39;a&#39;], row[&#39;c&#39;]), axis=1) . Flatten multi-level column index . df.columns=df.columns.get_level_values(0) . Pivot index levels to column . This is like a pivot table operation. Creates N columns based on N unique values in the row index. If you need to pivot on a non-index column, first add that to index using pd.set_index(col, append=True) . df=df.unstack() # This unstacks the right most index. To be more specific use order or name like df.unstack(0) or df.unstack(&#39;Year&#39;) # Vice versa: to pivot a column level to row index df=df.stack() . Binning based on value (cut) . cut splits a continuous data into equi-distant bins. Bins are skewed when outliers in the data . pd.cut([1,2,3,4,5,6,7,8], 4, labels=False) # Output: array([0, 0, 1, 1, 2, 2, 3, 3]) pd.cut([1,2,3,4,5,6,7,20], 4, labels=False) # Output: array([0, 0, 0, 0, 0, 1, 1, 3]) . Binning based on records (qcut) . qcut splits any data into equi-sized bins . pd.qcut([1,2,3,4,5,6,7,20], 4, labels=False) # Output: array([0, 0, 1, 1, 2, 2, 3, 3]) . this can be used in a group by to get decile level metrics . df.groupby(pd.qcut(df.col1,10, labels=False)).mean() . Add/Remove rows &amp; columns . Add Rows . Adding 1 row manually . df.append({&#39;name&#39;:&#39;banana&#39;, &#39;type&#39;:&#39;fruit&#39;, &#39;health_index&#39;:88, &#39;cost_index&#39;:98},ignore_index=True) # New index sequence will be created when ignore_index is True. Else will use original index and could result in duplicate indexes . Adding rows from another dataframe with matching columns (new columns will be created for non-matching columns. Missing columns will be NULLs . df.append(new_df) . Add columns . to add a column manually . df.assign(&#39;new_col&#39;,[1,2,3,4,5]) # Alternate approach df[&#39;new_col&#39;]=[1,2,3,4,5] # Add column dynamically creating a column based on a logic on existing column df[&#39;new_col&#39;]=[1 if x&gt;0 else 0 for x in df.col] . to create a new data frame with additional column . pd.concat([df,df.cost_index/2], axis=1) # this can also be used to create a dataframe from 2 or more series . Remove rows . Drop using index . df.drop([0,1]) # removes rows with index 0 &amp; 1 . Remove columns . drop using column names . df.drop(&#39;cost_index&#39;, axis=1) . Remove a level from multi-level index . drop the highest level from multi-level column index . df.columns=df.columns.droplevel() . drop a level from multi-level row index . pd.MultiIndex.droplevel(df,level=0) . Visualizations . Simple charts . df.cost_index.plot(kind=&#39;bar&#39;) # kinds: barh, hist, box, kde, density, area, scatter, hexbin, pie df.plot(subplots=True, figsize=(6, 6), layout=(3, -1)) # Layout -1 is to infer the number of columns based on data . Histogram . %matplotlib inline df.hist(bins=100, figsize=(40,30)) . Boxplot for each group . %matplotlib inline df.groupby(&#39;type&#39;).boxplot() . Scatter Matrix . scatter_matrix(df, alpha=0.2, figsize=(6, 6), diagonal=&#39;kde&#39;) . Bootstrap Plot . bootstrap_plot(data, size=50, samples=500, color=&#39;grey&#39;) . More vizualizations here . Nesting them all Use for continuity on next line . data[[&#39;email_domain&#39;,y_col]]. .groupby(&#39;email_domain&#39;) .agg({&#39;label&#39;:[&#39;mean&#39;,&#39;count&#39;]}) .sort_values([(&#39;label&#39;,&#39;count&#39;),(&#39;label&#39;,&#39;mean&#39;)], ascending=False) .style .format({&#39;B&#39;: &#39;{:0&lt;4.0f}&#39;, &#39;D&#39;: &#39;{:+.2f}&#39;}) .bar(subset=[&#39;B&#39;]) .",
            "url": "https://mohanganeesh.github.io/blog/2020/03/25/2020-03-25-Pandas-4-SQL-experts.html",
            "relUrl": "/2020/03/25/2020-03-25-Pandas-4-SQL-experts.html",
            "date": " • Mar 25, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # Title &gt; Awesome summary - toc: true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://mohanganeesh.github.io/blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://mohanganeesh.github.io/blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://mohanganeesh.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}